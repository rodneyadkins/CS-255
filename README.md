# CS-255
The task was to design an online system for the client Driverpass. They had a goal of making it easier for new drivers to pass the tests administered by the DMV. Ultimately their primary goal was to improve the pass rate of the tests. They set out to do this by providing both online self-paced learning and easy access to in-person driving lessons provided by experienced driving instructors.
During this project I did a good job of interpreting the requirements from the transcripts of a one-time interview with the customer. I was also able to develop the UML diagram to give the development team the tools they needed to be successful. 
It would have been nice to work with the development team to refine the UML diagrams to a greater degree of detail. To do this I would also have needed to communicate with the customer more to better narrow down priorities and requirements. Although I feel my diagrams were adequate in providing a good start for development, they certainly lacked the detail to be final documents. 
To interpret and implement the users’ needs I had to read the transcript several times and then reflect on what they were communicating. During this reflection I had to role play by putting myself in the customer’s shoes and thinking about how I, as a customer, would like such a system to work. I would then role play as a driver, secretary, and administrator at Driverpass. As a customer I would like a system that is easy to use, but my focus would be more on the completeness of the system. As an employee dealing with many customers, the focus was on ease of use so I could use the system in a very efficient manner. The next step was to evaluate my interpretation to make sure they did not conflict with the user’s communication during the interview. Designing software is no different than being a cook in a restaurant. It is important that we think about how we think it should be, but ultimately the customer is the user, and we need to deliver what they want.
I approach the design of software with an open mind. Then I break the system down into use cases and take them one by one. Systems can be complex. If we break complex systems down into easier to understand use cases and then classes, we can solve nearly any problem.



